https://www.cnblogs.com/D-DZDD/p/7197210.html

1，关于动态申请内存

答：内存分配方式三种：

（1）从静态存储区域分配：内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。

全局变量，static变量。

（2）在栈上创建：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，

函数执行结束时这些存储单元自动被释放。

栈内存分配运算 内置于处理器的指令集中，效率很高，但是分配的内存容量有限。

（3）用malloc或new申请内存之后，应该立即检查指针值是否为NULL.防止使用指针值为NULL的内存，

不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。避免数组或指针的下标越界，

特别要当心发生“多1”或者“少1”操作。动态内存的申请与释放必须配对，防止内存泄漏。

用free或delete释放了内存之后，立即将指针设置为NULL，防止产生“野指针”。从堆上分配，亦称动态内存分配。

程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。

动态内存的生存期由程序员决定，使用非常灵活。（int *pArray;   int MyArray[6];    pArray = &MyArray[0];）

如果在申请动态内存时找不到足够大的内存块，malloc和new将返回NULL指针，

判断指针是否为NULL，如果是 则马上用return语句终止本函数，

或者马上用exit(1)终止整个程序的运行，为new和malloc设置异常处理函数。


7，C++中的Const用法

答：char * const p;    // 指针不可改,也就说指针只能指向一个地址,不能更改为其他地址，修饰指针本身

char const * p;   // 所指内容不可改,也就是说*p是常量字符串，修饰指针所指向的变量

const char * const p 和 char const * const p; // 内容和指针都不能改

 

const修饰函数参数是它最广泛的一种用途，它表示函数体中不能修改参数的值，

传递过来的参数在函数内不可以改变，参数指针所指内容为常量不可变，参数指针本身为常量不可变

在引用或者指针参数的时候使用const限制是有意义的,而对于值传递的参数使用const则没有意义

 

const修饰类对象表示该对象为常量对象，其中的任何成员都不能被修改。

const修饰的对象，该对象的任何非const成员函数都不能被调用，因为任何非const成员函数会有修改成员变量的企图。

const修饰类的成员变量,表示成员常量，不能被修改，同时它只能在初始化列表中赋值。static const 的成员需在声明的地方直接初始。

const修饰类的成员函数，则该成员函数不能修改类中任何非const成员。一般写在函数的最后来修饰。

在函数实现部分也要带const关键字.

对于const类对象/指针/引用，只能调用类的const成员函数，因此，const修饰成员函数的最重要作用就是限制对于const对象的使用

 

使用const的一些建议：在参数中使用const应该使用引用或指针，而不是一般的对象实例

const在成员函数中的三种用法（参数、返回值、函数）要很好的使用；

const在成员函数中的三种用法（参数、返回值、函数）要很好的使用；

不要轻易的将函数的返回值类型定为const;除了重载操作符外一般不要将返回值类型定为对某个对象的const引用;

12，谈谈类和结构体的区别

答：结构体在默认情况下的成员都是public的,而类在默认情况下的成员是private的。结构体和类都必须使用new创建，

struct保证成员按照声明顺序在内存在存储，而类不保证。


46，简单描述Windows内存管理的方法。

答：程序运行时需要从内存中读出这段程序的代码，代码的位置必须在物理内存中才能被运行，

由于现在的操作系统中有非常多的程序运行着，内存中不能够完全放下，所以引出了虚拟内存的概念。

把哪些不常用的程序片断就放入虚拟内存，当需要用到它的时候在load入主存（物理内存）中。

内存管理也计算程序片段在主存中的物理位置，以便CPU调度。

 

内存管理有块式管理，页式管理，段式和段页式管理。现在常用段页式管理

块式管理：把主存分为一大块、一大块的，当所需的程序片断不在主存时就分配一块主存空间，

把程 序片断load入主存，就算所需的程序片度只有几个字节也只能把这一块分配给它。

这样会造成很大的浪费，平均浪费了50％的内存空间，但时易于管理。

页式管理：把主存分为一页一页的，每一页的空间要比一块一块的空间小很多，显然这种方法

的空间利用率要比块式管理高很多

段式管理：把主存分为一段一段的，每一段的空间又要比一页一页的空间小很多，

这种方法在空间利用率上又比页式管理高很多，但是也有另外一个缺点。一个程序片断可能会被分为几十段，

这样很多时间就会被浪费在计算每一段的物理地址上，计算机最耗时间的大家都知道是I/O吧

段页式管理：结合了段式管理和页式管理的优点。把主存分为若干页，每一页又分为若干段，好处就很明显
